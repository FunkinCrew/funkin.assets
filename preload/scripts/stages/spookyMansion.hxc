import flixel.FlxG;
import funkin.Conductor;
import funkin.audio.FunkinSound;
import funkin.data.event.SongEventRegistry;
import funkin.play.PlayState;
import funkin.play.stage.Stage;
import funkin.util.Constants;
import funkin.util.HapticUtil;

class SpookyMansionStage extends Stage
{
  function new()
  {
    super('spookyMansion');
  }

  var lightningStrikeBeat:Int = 0;
  var lightningStrikeOffset:Int = 8;
  var bfAnimations = [];

  function onSongLoaded(scriptEvent:SongLoadScriptEvent)
  {
    super.onSongLoaded(scriptEvent);
    var songEvents = scriptEvent.events;

    for (event in songEvents)
    {
      if (event.eventKind == "PlayAnimation")
      {
        var eventProps = event.value;
        if ((eventProps.target == "boyfriend" || eventProps.target == "bf") && eventProps.force)
        {
          bfAnimations.push(event);
        }
      }
    }
  }

  function doLightningStrike(playSound:Bool, beat:Int):Void
  {
    if (playSound)
    {
      FunkinSound.playOnce(Paths.soundRandom('thunder_', 1, 2), 1.0);
    }

    getNamedProp('halloweenBG').animation.play('lightning');

    lightningStrikeBeat = beat;
    var lightningStrikeMs = Conductor.instance.getBeatTimeInMs(lightningStrikeBeat);
    lightningStrikeOffset = FlxG.random.int(8, 24);

    var bfAnimationsToPlay = SongEventRegistry.queryEvents(bfAnimations, lightningStrikeMs);
    var bfHasAnimationToPlay:Bool = false;
    if (bfAnimationsToPlay.length > 0) bfHasAnimationToPlay = true;

    if (getBoyfriend() != null && getBoyfriend().hasAnimation('scared') && !bfHasAnimationToPlay)
    {
      getBoyfriend().playAnimation('scared', true, true);
    }

    if (getGirlfriend() != null && getGirlfriend().hasAnimation('scared'))
    {
      getGirlfriend().playAnimation('scared', true, true);
    }

    triggerLightningHaptics();
  }

  var doPostShockHaptics:Bool = false;

  function triggerLightningHaptics()
  {
    HapticUtil.vibrate(0, 0.05, 1);

    doPostShockHaptics = true;
  }

  /**
   * If your stage uses additional assets not specified in the JSON,
   * make sure to specify them like this, or they won't get cached in the loading screen.
   */
  function fetchAssetPaths():Array<String>
  {
    var results:Array<String> = super.fetchAssetPaths();
    results.push(Paths.sound('thunder_1'));
    results.push(Paths.sound('thunder_2'));
    return results;
  }

  function onBeatHit(event:SongTimeScriptEvent)
  {
    super.onBeatHit(event);

    // Play lightning on sync at the start of this specific song.
    // TODO: Rework this after chart format redesign.
    if (PlayState.instance.currentSong != null)
    {
      if (event.beat == 4 && PlayState.instance.currentSong.id == "spookeez")
      {
        doLightningStrike(false, event.beat);
      }
    }

    // Play lightning at random intervals.
    if (FlxG.random.bool(10) && event.beat > (lightningStrikeBeat + lightningStrikeOffset))
    {
      doLightningStrike(true, event.beat);
    }
  }

  var postShockCounter:Int = 0;
  var counterTargetNum:Int = 10;

  function onStepHit(event:SongTimeScriptEvent)
  {
    super.onStepHit(event);

    if (doPostShockHaptics)
    {
      postShockCounter++;

      var postShockAmplitude:Float = 0.05 * (counterTargetNum - postShockCounter) * 2.5;
      HapticUtil.vibrate(0, 0.01, postShockAmplitude, 0);

      if (postShockCounter == counterTargetNum)
      {
        doPostShockHaptics = false;
        postShockCounter = 0;
      }
    }
  }

  function onSongRetry(event:ScriptEvent)
  {
    super.onSongRetry(event);

    // Properly reset lightning when restarting the song.
    lightningStrikeBeat = 0;
    lightningStrikeOffset = 8;
  }

  function onCountdownStart(event:CountdownScriptEvent):Void
  {
    super.onCountdownStart(event);

    // Reset lightning variables at the start of every song
    lightningStrikeBeat = 0;
    lightningStrikeOffset = 8;
  }
}
