import funkin.data.song.SongRegistry;
import funkin.play.song.Song;
import funkin.save.Save;
import funkin.play.PlayState;
import funkin.play.PlayStatePlaylist;
import funkin.play.character.BaseCharacter;
import funkin.data.character.CharacterDataParser;
import funkin.play.character.CharacterType;
import funkin.graphics.FunkinSprite;
import funkin.play.stage.Bopper;
import funkin.Conductor;
import flixel.tweens.FlxEase;
import flixel.util.FlxTimerManager;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.util.Constants;
import funkin.modding.base.ScriptedFlxSpriteGroup;
import funkin.modding.events.SongTimeScriptEvent;
import funkin.modding.events.ScriptEventDispatcher;
import funkin.play.cutscene.VideoCutscene;
import flixel.FlxG;
import funkin.Paths;

class StressSong extends Song
{
  var hasPlayedCutscene:Bool;
  var tankmanGroup:TankmanSpriteGroup = null;

  var cutsceneConductor:Conductor;
  var cutsceneTimerManager:FlxTimerManager;
  var cutsceneMusic:FunkinSound;

  public function new()
  {
    super('stress');

    hasPlayedCutscene = false;
  }

  public override function listAltInstrumentalIds(difficultyId:String, variationId:String):Array<String>
  {
    var results:Array<String> = super.listAltInstrumentalIds(difficultyId, variationId);

    if (difficultyId == 'easy' || difficultyId == 'normal' || difficultyId == 'hard')
    {
      var hasBeatenPicoMix = Save.instance.hasBeatenSong(this.id, null, 'pico');

      if (!hasBeatenPicoMix) results = [for (id in results) if (id != 'pico') id];
    }

    return results;
  }

  public override function onCountdownStart(event:CountdownScriptEvent):Void
  {
    super.onCountdownStart(event);

    // Skip the cutscene unless we are in Story Mode.
    if (!PlayStatePlaylist.isStoryMode) hasPlayedCutscene = true;

    if (!hasPlayedCutscene)
    {
      trace('Pausing countdown to play a video cutscene (`stress`)');

      hasPlayedCutscene = true;

      event.cancel(); // CANCEL THE COUNTDOWN!

      runCutscene();
    }

    if (tankmanGroup != null && !tankmanGroup.scriptCall('isValid'))
    {
      // Destroy the tankman group if it's not valid.
      tankmanGroup.destroy();
      PlayState.instance.currentStage.remove(tankmanGroup);
      tankmanGroup = null;
    }

    if (tankmanGroup == null)
    {
      // Initialize the tankman group if it's not available.
      trace('Initializing tankman group... ' + PlayState.instance.currentVariation);
      tankmanGroup = ScriptedFlxSpriteGroup.init('TankmanSpriteGroup');
    }

    if (tankmanGroup != null)
    {
      // resets the tankmen!
      tankmanGroup.scriptCall('reset');

      tankmanGroup.zIndex = 30;
      PlayState.instance.currentStage.add(tankmanGroup);
      PlayState.instance.currentStage.refresh();
    }
    else
    {
      trace('Failed to initialize tankman group!');
    }
  }

  var picoCutscene:Bopper;
  var fakeGeef:BaseCharacter;

  function runCutscene()
  {
    PlayState.instance.isInCutscene = true;
    PlayState.instance.camHUD.visible = false;

    cutsceneTimerManager = new FlxTimerManager();

    var musicPath:String = 'stressCutscene/stressCutscene';

    if (Constants.CENSOR_EXPLETIVES)
      musicPath += '-censored';

    cutsceneMusic = FunkinSound.load(Paths.music(musicPath, "week7"), 1, false);

    // we will ALL be calling daddy dearest daddy
    var daddy:BaseCharacter = PlayState.instance.currentStage.getDad();
    daddy.visible = false;

    var geef:BaseCharacter = PlayState.instance.currentStage.getGirlfriend();
    geef.visible = false;

    var beef:BaseCharacter = PlayState.instance.currentStage.getBoyfriend();
    beef.visible = false;

    fakeGeef = CharacterDataParser.fetchCharacter('gf-tankmen');
    setupCharacter(fakeGeef, CharacterType.GF);
    PlayState.instance.currentStage.add(fakeGeef);

    var fakeBeef:BaseCharacter = CharacterDataParser.fetchCharacter('bf');
    setupCharacter(fakeBeef, CharacterType.BF);
    PlayState.instance.currentStage.add(fakeBeef);

    var tankmanCutscene:FunkinSprite = new FunkinSprite(daddy.x - 100, daddy.y - 102);
    tankmanCutscene.loadTextureAtlas("cutscene/tankman", "week7");
    tankmanCutscene.anim.addByFrameLabel("godEffingDamnIt", "GOD EFFING DAMMIT", 24, false);
    tankmanCutscene.anim.addByFrameLabel("lookWhoItIs", "Sexually Ambiguous", 24, false);
    tankmanCutscene.zIndex = daddy.zIndex;
    PlayState.instance.currentStage.add(tankmanCutscene);

    var picoCutscene:FunkinSprite = new FunkinSprite(fakeGeef.x - 739, fakeGeef.y - 482);
    picoCutscene.loadTextureAtlas("cutscene/pico", "week7");
    picoCutscene.anim.addByFrameLabel("gfTurn", "gf turns demon", 24, false);
    picoCutscene.anim.addByFrameLabel("picoSaves", "obliteration", 24, false);
    picoCutscene.anim.addByFrameLabel("idle", "pico idle", 24, false);
    picoCutscene.zIndex = geef.zIndex;
    picoCutscene.visible = false;
    PlayState.instance.currentStage.add(picoCutscene);

    PlayState.instance.currentStage.refresh();

    var bfPos:Array<Float> = [
      PlayState.instance.currentStage.getBoyfriend().cameraFocusPoint.x,
      PlayState.instance.currentStage.getBoyfriend().cameraFocusPoint.y
    ];

    var gfPos:Array<Float> = [
      fakeGeef.cameraFocusPoint.x,
      fakeGeef.cameraFocusPoint.y - 100 // shushhhh
    ];

    var tankmanPos:Array<Float> = [
      PlayState.instance.currentStage.getDad().cameraFocusPoint.x,
      PlayState.instance.currentStage.getDad().cameraFocusPoint.y
    ];

    cutsceneConductor = new Conductor();

    var songMusicData:Null<SongMusicData> = SongRegistry.instance.parseMusicData('stressCutscene');
    if (songMusicData != null) cutsceneConductor.mapTimeChanges(songMusicData.timeChanges);
    cutsceneConductor.onStepHit.add(onCutsceneStepHit);
    cutsceneConductor.onBeatHit.add(onCutsceneBeatHit);

    PlayState.instance.currentCameraZoom = 0.9 * 1.15;

    new FlxTimer(cutsceneTimerManager).start(0, function(_) {
      tankmanCutscene.anim.play('godEffingDamnIt', true);
      cutsceneMusic.play();
    });

    new FlxTimer(cutsceneTimerManager).start(15.1, function(_) {
      PlayState.instance.resetCamera(false, false, false);
      PlayState.instance.cameraFollowPoint.setPosition(gfPos[0], gfPos[1]);

      fakeGeef.destroy();
      fakeGeef = null;

      picoCutscene.visible = true;
      picoCutscene.anim.play("gfTurn", true);

      var picoAnimPhase:Int = 0;
      picoCutscene.anim.onFinish.add((_) -> {
        switch(picoAnimPhase)
        {
          case 0:
            picoCutscene.anim.play('picoSaves', true);
          case 1:
            picoCutscene.anim.play('idle', true);
          default:
            picoCutscene.visible = false;
            geef.visible = true;
        }

        picoAnimPhase++;
      });

      PlayState.instance.tweenCameraZoom((0.9 * 1.15) * 1.3, 2.1, true, FlxEase.quadInOut);
    });

    new FlxTimer(cutsceneTimerManager).start(17.3, function() {
      PlayState.instance.currentCameraZoom = 0.8;

      // wait 2 frames before changing back to the real BF, so the gf falling animation makes sense
      new FlxTimer(cutsceneTimerManager).start(2 / 24, function(_) {
        fakeBeef.destroy();
        fakeBeef = null;

        beef.visible = true;
        beef.playAnimation("bfCatch", true, true);
        beef.animation.onFinish.addOnce(() -> {
          // force the idle animation.
          beef.canPlayOtherAnims = true;
          beef.dance(true);
        });
      });
    });

    new FlxTimer(cutsceneTimerManager).start(19.6, function(_) {
      tankmanCutscene.anim.play("lookWhoItIs", true);
    });

    new FlxTimer(cutsceneTimerManager).start(20.3, function(_) {
      PlayState.instance.resetCamera(false, false, false);
      PlayState.instance.cameraFollowPoint.setPosition(tankmanPos[0], tankmanPos[1]);
      PlayState.instance.tweenCameraZoom(0.9, 5, true, FlxEase.expoOut); // Zoom in, as one of the audience members get cut off.
    });

    new FlxTimer(cutsceneTimerManager).start(31.5, function(_) {
      PlayState.instance.cameraFollowPoint.setPosition(bfPos[0], bfPos[1]);
      PlayState.instance.resetCamera(false, false);

      PlayState.instance.currentCameraZoom = 0.9 * 1.4;
      PlayState.instance.tweenCameraZoom((0.9 * 1.4) + 0.1, 0.5, true, FlxEase.elasticOut);

      beef.playSingAnimation(2, true);

      beef.animation.onFinish.addOnce(() -> {
        beef.dance(true);

        PlayState.instance.cameraFollowPoint.setPosition(tankmanPos[0], tankmanPos[1]);
        PlayState.instance.resetCamera(false, false);

        PlayState.instance.currentCameraZoom = ((0.9 * 1.4) + 0.1) / 1.4;
      });
    });

    new FlxTimer(cutsceneTimerManager).start(35.1, function(_) {
      cutsceneMusic.fadeOut(0.5, 0, function (_) {
        cutsceneMusic.stop();
        cutsceneMusic.destroy();
        cutsceneConductor = null;
        cutsceneMusic = null;
      });
    });

    new FlxTimer(cutsceneTimerManager).start(35.1, function(_) {
      tankmanCutscene.destroy();
      daddy.visible = true;

      picoCutscene.destroy();
      picoCutscene = null;

      PlayState.instance.tweenCameraZoom(1, 0.5, false, FlxEase.quadInOut);

      PlayState.instance.isInCutscene = false;
			PlayState.instance.startCountdown();
    });
  }

  /**
   * Stolen from Stage.hx
   */
  function setupCharacter(character:BaseCharacter, charType:CharacterType):Void
  {
    var stageCharData:StageDataCharacter = null;
    switch(charType)
    {
      case CharacterType.BF:
        stageCharData = PlayState.instance.currentStage._data.characters.bf;
        character.flipX = !character.getDataFlipX();
      case CharacterType.GF:
        stageCharData = PlayState.instance.currentStage._data.characters.gf;
        character.flipX = character.getDataFlipX();
      case CharacterType.DAD:
        stageCharData = PlayState.instance.currentStage._data.characters.dad;
        character.flipX = character.getDataFlipX();
    }

    character.resetCharacter(true);

    if(stageCharData == null)
      return;

    character.zIndex = stageCharData.zIndex;

    character.x = stageCharData.position[0] - character.characterOrigin.x;
    character.y = stageCharData.position[1] - character.characterOrigin.y;

    var finalScale = character.getBaseScale() * stageCharData.scale;
    character.setScale(finalScale); // Don't use scale.set for characters!
    character.cameraFocusPoint.x += stageCharData.cameraOffsets[0];
    character.cameraFocusPoint.y += stageCharData.cameraOffsets[1];

    character.scrollFactor.x = stageCharData.scroll[0];
    character.scrollFactor.y = stageCharData.scroll[1];

    character.alpha = stageCharData.alpha;
    character.angle = stageCharData.angle;
  }

  function onUpdate(event:UpdateScriptEvent)
  {
    super.onUpdate(event);

    if (cutsceneTimerManager != null) cutsceneTimerManager.update(event.elapsed);

    if (cutsceneConductor != null && cutsceneMusic != null)
    {
      cutsceneConductor.update(cutsceneMusic.time);
    }
	}

  function onCutsceneStepHit():Void
  {
    var event = new SongTimeScriptEvent("STEP_HIT", cutsceneConductor.currentBeat, cutsceneConductor.currentStep);
    if(fakeGeef != null) ScriptEventDispatcher.callEvent(fakeGeef, event);
  }

  function onCutsceneBeatHit():Void
  {
    var event = new SongTimeScriptEvent("BEAT_HIT", cutsceneConductor.currentBeat, cutsceneConductor.currentStep);
    if(fakeGeef != null) ScriptEventDispatcher.callEvent(fakeGeef, event);
  }

  function kill():Void
  {
    cleanupTankmanGroup();
  }

  function cleanupTankmanGroup():Void
  {
    if (tankmanGroup != null)
    {
      PlayState.instance.currentStage.remove(tankmanGroup);
      tankmanGroup.destroy();
      tankmanGroup = null;
    }
  }
}
