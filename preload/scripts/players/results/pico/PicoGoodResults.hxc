import flixel.math.FlxPoint;
import flixel.FlxG;
import funkin.graphics.FunkinSprite;
import funkin.Preferences;
import funkin.util.HapticUtil;

class PicoGoodResults extends FunkinSprite
{
  var WHITE_FLASH_FRAMES:Array<Int> = [
    43, 49, 81, 87, 143, 149, 156, 338, 344, 351, 364, 517, 521, 537, 546, 559, 570, 576, 676, 682, 714, 720, 776, 782, 789
  ];
  var BLACK_FLASH_FRAMES:Array<Int> = [
    46, 52, 84, 90, 147, 153, 158, 335, 345, 353, 359, 362, 366, 523, 529, 533, 541, 547, 554, 563, 569, 577, 580, 679, 685, 717, 723, 780, 786, 791
  ];

  function new(x:Float, y:Float)
  {
    super(x, y);
    loadTextureAtlas("resultScreen/results-pico/resultsGOOD", "shared");

    // TODO: Make it easier to get the current result state

    var whiteFlash:FunkinSprite = new FunkinSprite(0, 0).makeSolidColor(FlxG.width, FlxG.height, 0x33FFFFFF);
    var blackFlash:FunkinSprite = new FunkinSprite(0, 0).makeSolidColor(FlxG.width, FlxG.height, 0x33000000);

    var resultState:ResultState = FlxG.state;
    while (resultState.subState != null)
    {
      resultState = resultState.subState;
    }

    resultState.add(whiteFlash);
    whiteFlash.zIndex = 1000;
    whiteFlash.visible = false;

    resultState.add(blackFlash);
    blackFlash.zIndex = 1000;
    blackFlash.visible = false;

    var first:Bool = false;

    anim.onFrameChange.add((animation:String, frame:Int) -> {
      if (animation == "pico good placeholder" && this.visible)
      {
        playAnimation();
        return;
      }

      if ((WHITE_FLASH_FRAMES.contains(frame) || BLACK_FLASH_FRAMES.contains(frame)) && HapticUtil.hapticsAvailable)
      {
        HapticUtil.vibrate(0, 0.01, 1);
      }

      if (!Preferences.flashingLights) return;

      if (!first)
      {
        whiteFlash.visible = true;
        whiteFlash.alpha = 0.01;
        blackFlash.visible = true;
        blackFlash.alpha = 0.01;
        first = true;
      }
      else if (WHITE_FLASH_FRAMES.contains(frame))
      {
        whiteFlash.visible = true;
        whiteFlash.alpha = 1;
        blackFlash.visible = false;
        blackFlash.alpha = 0;
      }
      else if (BLACK_FLASH_FRAMES.contains(frame))
      {
        whiteFlash.visible = false;
        whiteFlash.alpha = 0;
        blackFlash.visible = true;
        blackFlash.alpha = 1;
      }
      else
      {
        whiteFlash.visible = false;
        blackFlash.alpha = 0;
        blackFlash.visible = false;
        blackFlash.alpha = 0;
      }
    });

    anim.onFinish.add((name:String) -> {
      if (name == "pico good placeholder") return;
      trace('Looping Pico shooting animation...');
      anim.play("loop", true);
      anim.curAnim.looped = true;
    });
  }

  public function playAnimation():Void
  {
    if (FlxG.random.bool(5))
    {
      trace('Playing special Fatass animation...');
      anim.play("intro fat gf", true, false, 0);
    }
    else if (FlxG.random.bool(20))
    {
      trace('Playing special Cass animation...');
      anim.play("intro cass", true, false, 0);
    }
    else
    {
      trace('Playing Pico shooting animation...');
      anim.play("intro", true, false, 0);
    }
  }

  override function update(elapsed:Float):Void
  {
    super.update(elapsed);

    FlxG.watch.addQuick('picoResultsPos', this.offset);

    var resultState:ResultState = FlxG.state;
    while (resultState.subState != null)
    {
      resultState = resultState.subState;
    }

    FlxG.watch.addQuick('cameraBG', new FlxPoint(resultState.cameraBG.x, resultState.cameraBG.y));
    FlxG.watch.addQuick('cameraScroll', new FlxPoint(resultState.cameraScroll.x, resultState.cameraScroll.y));
    FlxG.watch.addQuick('cameraEverything', new FlxPoint(resultState.cameraEverything.x, resultState.cameraEverything.y));
  }
}
